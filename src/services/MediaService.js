import ImageResizer from '@bam.tech/react-native-image-resizer';
import RNFS from 'react-native-fs';

const TARGET_WIDTH = 1080;
const TARGET_QUALITY = 80;

/**
 * MediaService - Handles media processing operations
 * - Image compression
 * - Video compression
 * - Thumbnail generation
 * - File management
 */
class MediaService {
  /**
   * Compress and resize image
   * @param {string} uri - Image URI
   * @param {number} width - Target width (default: 1080)
   * @param {number} quality - Quality 0-100 (default: 80)
   * @returns {Promise<string>} Compressed image URI
   */
  async compressImage(uri, width = TARGET_WIDTH, quality = TARGET_QUALITY) {
    try {
      const response = await ImageResizer.createResizedImage(
        uri,
        width,
        width * 2, // Max height (maintains aspect ratio)
        'JPEG',
        quality,
        0, // rotation
        undefined, // outputPath (auto-generate)
        false, // keepMeta
        {
          mode: 'contain',
          onlyScaleDown: true,
        }
      );
      return response.uri;
    } catch (error) {
      console.error('Image compression error:', error);
      return uri; // Return original if compression fails
    }
  }

  /**
   * Generate thumbnail for video
   * @param {string} videoUri - Video URI
   * @param {number} timeStamp - Timestamp in seconds (default: 0)
   * @returns {Promise<string>} Thumbnail URI
   * Note: Requires react-native-video-thumbnails or native implementation
   */
  async generateVideoThumbnail(videoUri, timeStamp = 0) {
    try {
      // TODO: Implement with react-native-video-thumbnails or native module
      // For now, return null (thumbnail will be generated by react-native-video)
      console.log('Thumbnail generation not yet implemented:', videoUri);
      return null;
    } catch (error) {
      console.error('Thumbnail generation error:', error);
      return null;
    }
  }

  /**
   * Get file size in bytes
   * @param {string} uri - File URI
   * @returns {Promise<number>} File size in bytes
   */
  async getFileSize(uri) {
    try {
      const stat = await RNFS.stat(uri);
      return stat.size;
    } catch (error) {
      console.error('File size error:', error);
      return 0;
    }
  }

  /**
   * Copy file to app's document directory
   * @param {string} sourceUri - Source file URI
   * @param {string} fileName - Target file name
   * @returns {Promise<string>} New file URI
   */
  async copyToLocalStorage(sourceUri, fileName) {
    try {
      const documentsPath = RNFS.DocumentDirectoryPath;
      const targetPath = `${documentsPath}/${fileName}`;
      
      // Copy file
      await RNFS.copyFile(sourceUri, targetPath);
      
      return `file://${targetPath}`;
    } catch (error) {
      console.error('File copy error:', error);
      return sourceUri; // Return original if copy fails
    }
  }

  /**
   * Delete file
   * @param {string} uri - File URI
   * @returns {Promise<boolean>} Success status
   */
  async deleteFile(uri) {
    try {
      const filePath = uri.replace('file://', '');
      await RNFS.unlink(filePath);
      return true;
    } catch (error) {
      console.error('File delete error:', error);
      return false;
    }
  }

  /**
   * Process media item (compress, generate thumbnail, etc.)
   * @param {Object} mediaItem - Media item object
   * @returns {Promise<Object>} Processed media item
   */
  async processMediaItem(mediaItem) {
    try {
      let processedUri = mediaItem.uri;
      let thumbnailUri = null;

      // Compress images
      if (mediaItem.type === 'image') {
        processedUri = await this.compressImage(mediaItem.uri);
      }

      // Generate thumbnail for videos
      if (mediaItem.type === 'video') {
        thumbnailUri = await this.generateVideoThumbnail(mediaItem.uri);
      }

      // Get file size
      const fileSize = await this.getFileSize(processedUri);

      return {
        ...mediaItem,
        uri: processedUri,
        thumbnailUri,
        fileSize,
        processed: true,
      };
    } catch (error) {
      console.error('Media processing error:', error);
      return mediaItem; // Return original if processing fails
    }
  }
}

export default new MediaService();

